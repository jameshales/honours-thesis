\chapter{Technical preliminaries}

In this chapter we will provide some of the technical preliminaries that are
required throughout this paper. We give a short introduction to modal, doxastic,
and epistemic logics, and give the definition of a refinement that is used by
refinement quantified modal logics. We also give some useful results that we
refer to later in the paper.

\section{Modal, doxastic and epistemic logics}

% Introduction to modal logic
As has been said earlier, modal logic is used to reason about the intrinsic
properties of Kripke models. Under the {\em possible worlds} interpretation of
modal logic, a Kripke model is said to encode information about the possible
ways that the world could be, with respect to a specific set of facts (modelled
as propositional atoms). If we use the analogy of knowledge, then we can view
the possible worlds as a way to represent the notion of imperfect knowledge. If
an agent knew everything that there was to know about the world, then they
would only consider one world possible: the actual world; whereas, if an agent
was unsure about some fact $p$, then the agent would consider at least two
worlds possible: the world where $p$ is true, and the world where $p$ is false.

Modal logics allow us to reason about these possible worlds by qualifying
statements with operators known as modalities. If we are considering a
multi-agent setting, where there is a set $A$ of agents, then modal logic
introduces the operators $\knows_a$ and $\suspects_a$ for each agent $a \in A$.
We can qualify a statement $\phi$ with these operators, where $\knows_a \phi$
means that $\phi$ is true in every world that the agent $a$ considers possible,
and $\suspects_a \phi$ is true in at least one of the worlds that the agent $a$
considers possible. In basic modal logic, the operator $\knows_a$ is said to
represent necessity; $\knows_a \phi$ means that $a$ considers $\phi$ to be
necessarily true. In doxastic and epistemic logic on the other hand, $\knows_a$
is said to represent belief and knowledge respectively.

To introduce modal logic, we will begin with the definition of a Kripke model,
the definition of the modal language \lang{}, and the semantics of modal logic.

% Definition of Kripke models
Let $A$ be a non-empty, finite set of agents, and let $P$ be a non-empty,
countable set of propositional atoms.

\begin{definition}[Kripke model]
A \textit{Kripke model} $M = (S, R, V)$ consists of a \textit{domain} $S$, which
is a set of states (or worlds), \textit{accessibility} $R : A \to \mathcal{P}(S
\times S)$, and a \textit{valuation} $V : P \to \mathcal{P}(S)$. 

The class of all Kripke models is called \classK{}. We write $M \in \classK{}$
to denote that $M$ is a Kripke model.
\end{definition}

For $R(a)$, we write $R_a$. We write $sR_a$ for $\{t \mid (s, t) \in R_a\}$ and
we write $R_at$ for $\{s \mid (s, t) \in R_a\}$. As we will be required to
discuss several models at once, we will use the convention that $M = (S^M, R^M,
V^M)$, $N = (S^N, R^N, V^N)$, and so on. For $s \in S^M$ we will let $M_s$ refer
to the pair $(M, s)$, also known as the pointed Kripke model of $M$ at state
$s$.

As we have seen, a Kripke model is essentially a set of states, a set of
relations over those states, and a valuation over the set of states. Under the
possible worlds interpretation, we view each of those states as a possible
world, and the actual world is simply one of these possible worlds. Sometimes
we may designate the actual world by referring to a pointed Kripke model $M_s$,
where the state $s$ is the actual world. The valuation at each state represents
the propositional atoms that are true at that state, and the set of relations
defines which worlds each agents considers to be possible at each state. If $t
\in sR_a$, then we say that the agent $a$ considers the state $t$ to be
possible when $s$ is the actual world. Thus the set $sR_a$ is the set of
possible worlds for $a$ in the state $s$.

Modal logics are interpreted over classes of Kripke models. The simplest normal
modal logic, \logicK{}, is interpreted over the class of all Kripke models,
\classK{}. Variants of modal logic are interpreted over subclasses of \classK{},
which impose structural constraints on the types of Kripke models that are
allowed. Doxastic logic, \logicKD{}, and epistemic logic, \logicS{}, are two
variants of modal logic that are interpreted over different classes of Kripke
models: the class of doxastic models, \classKD{}, and the class of epistemic
models, \classS{}, respectively. As we will see later, the constraints that are
placed on these classes of models gives us properties that make doxastic logic
and epistemic logic represent simple notions that we have about belief and
knowledge.

\begin{definition}[Doxastic model]
A \textit{doxastic model} is a Kripke model $M = (S, R, V)$ such that the
relation $R_a$ is serial, transitive, and Euclidean for all $a \in A$. The class
of all doxastic models is called \classKD{}. We write $M \in \classKD{}$ to
denote that $M$ is a doxastic model.
\end{definition}

\begin{definition}[Epistemic model]
An \textit{epistemic model} is a Kripke model $M = (S, R, V)$ such that the
relation $R_a$ is an equivalence relation for all $a \in A$. The class of all
epistemic models is called \classS{}. We write $M \in \classS{}$ to denote that
$M$ is an epistemic model.
\end{definition}

Throughout this paper we will be presenting results in both doxastic and
epistemic logic.  As such, when we are discussing doxastic logic, we will
assume that all Kripke models are implicitly doxastic models, and likewise when
we are discussing epistemic logic, we will assume that all Kripke models are
implicitly epistemic models, unless this has to be explicitly proven as part of
a proof. When we are discussing results in general modal logic, we will not
assume any restrictions on the Kripke models.

We will now give a precise definition of the language, \lang{}, of basic modal
logic, and its semantics over a general class of Kripke models.

\begin{definition}[Language of \lang{}]
Given a finite set of agents $A$ and a set of propositional atoms $P$, the
language of \langF{} is defined by the following abstract syntax:
$$
\alpha ::=  p \bnfalt
            \neg \alpha \bnfalt
            \phi \land \alpha \bnfalt
            \knows_a \alpha
$$
where $p \in P$, $a \in A$ and $\alpha \in \lang{}$.
\end{definition}

Standard abbreviations include:
$\top ::= \phi \lor \neg \phi$;
$\bot ::= \neg \top$;
$\phi \lor \psi ::= \neg (\neg \phi \land \neg \psi)$;
$\phi \implies \psi ::= \neg \phi \lor \psi$;
and $\suspects_a \phi ::= \neg \knows_a \neg \phi$.

\begin{definition}[Semantics of \logicC{}]
Let \classC{} be a class of Kripke models, and let $M = (S, R, V) \in \classC$
be a Kripke model taken from \classC{}. The interpretation of $\phi$ is defined
inductively:
\begin{eqnarray*}
M_s &\entails& p \text{ iff } s \in V_p\\
M_s &\entails& \neg \phi \text{ iff } M_s \nentails \phi\\
M_s &\entails& \phi \land \psi \text{ iff } M_s \entails \phi \text{ and } M_s
\entails \psi\\
M_s &\entails& \knows_a \phi \text{ if for all } t \in S : (s, t) \in R_a \text{
implies } M_t \entails \phi
\end{eqnarray*}
\end{definition}

We say that a formula $\phi$ is {\em satisfied} by a pointed Kripke model $M_s
\in \classC$ if and only if $M_s \entails \phi$. We say that $\phi$ is satisfied
by a Kripke model $M \in \classC$ if and only if $M_s \entails \phi$ for some $s
\in S^M$. We say that $\phi$ is {\em satisfied} by a class of Kripke models
$\classC$ if and only if it is satisfied by every Kripke model $M \in \classC$.
We say that $\phi$ is {\em valid} in a Kripke model $M \in \classC$ if and only
if $M_s \entails \phi$ for every $s \in S^M$. We write $M \entails \phi$. We say
that $\phi$ is {\em valid} in a class of Kripke models $\classC$ if and only if
$M \entails \phi$ for every $M \in \classC$. We write $\classC \entails \phi$.

The logics \logicK{}, \logicKD{} and \logicS{} are instances of \logicC{} with
classes \classK{}, \classKD{} and \classS{} respectively. It should be noted
that \logicKD{} is a conservative extension of \logicK{}, and \logicS{} is a
conservative extension of \logicKD{} (and also of \logicK{}). This means that
every valid formula in \logicK{} is also valid in \logicKD{}, and likewise for
\logicKD{} and \logicS{}. This is because any formula that is valid with respect
to a particular class of Kripke models is also valid for any subclass of those
Kripke models.

\begin{proposition}[Properties of \logicK{}, \logicKD{} and
\logicS{}]\label{pre-properties}
Let $\phi, \psi \in \lang$. Then the following are valid:

\begin{enumerate}
\item\label{pre-property-k} $\classK \entails \knows_a (\phi \implies \psi) \implies \knows_a \phi
\implies \knows_a \psi$
\item\label{pre-property-conj} $\classK \entails \knows_a \phi \land \knows_a \psi \iff \knows_a (\phi \land \psi)$
\item $\classK \entails \suspects_a \phi \lor \suspects_a \psi \iff \suspects_a (\phi
\lor \psi)$
\item\label{pre-property-d} $\classKD \entails \knows_a \phi \implies \suspects_a \phi$
\item\label{pre-property-4} $\classKD \entails \knows_a \phi \implies \knows_a \knows_a \phi$
\item\label{pre-property-5} $\classKD \entails \neg\knows_a \phi \implies \knows_a \neg \knows_a \phi$
\item\label{pre-property-t} $\classS \entails \knows_a \phi \implies \phi$
\end{enumerate}
\end{proposition}

\begin{proof}
\begin{enumerate}
\item Let $M_s \in \classK{}$ such that $M_s \entails \knows_a (\phi \implies \psi)$
and $M_s \entails \knows_a \phi$. Then for every $t \in sR_a$, we have $M_t
\entails \phi \implies \psi$ and $M_t \entails \phi$. Therefore for every $t \in sR_a$,
we have $M_t \entails \psi$, and therefore we have that $M_s \entails \knows_a \psi$.
\item Omitted.
\item Omitted.
\item Let $M_s \in \classKD{}$ such that $M_s \entails \knows_a \phi$. Then for
every $t \in sR_a$, we have $M_t \entails \phi$. As $M_s \in \classKD{}$, we have
that $R_a$ is serial. Therefore $sR_a \neq \emptyset$, and so there exists some
$t \in sR_a$ such that $M_t \entails \phi$. Therefore $\suspects_a \phi$.
\item Let $M_s \in \classKD{}$ such that $M_s \entails \knows_a \phi$. Then
consider $t \in sR_a$ and $t' \in tR_a$. As $M_s \in \classKD{}$, we have that
$R_a$ is transitive. Therefore $t' \in sR_a$, and so $M_{t'} \entails \phi$.
Therefore $M_t \entails \knows_a \phi$, and so $M_s \entails \knows_a \knows_a \phi$. 
\item Let $M_s \in \classKD{}$ such that $M_s \entails \neg \knows_a \phi$. Then
there exists some $t \in sR_a$ such that $M_t \entails \neg \phi$. Then consider
$t' \in sR_a$. As $M_s \in \classKD{}$, we have that $R_a$ is Euclidean.
Therefore $t \in t'R_a$, and so $M_t \entails \neg \knows_a \phi$. Therefore $M_s
\entails \knows_a \neg \knows_a \phi$.
\item Let $M_s \in \classS{}$ such that $M_s \entails \knows_a \phi$. Then for
every $t \in sR_a$, we have $M_t \entails \phi$. As $M_s \in \classS{}$, we have
that $R_a$ is reflexive. Therefore $s \in sR_a$, and so $M_s \entails \phi$.
\end{enumerate}
\end{proof}

We note that the properties described in Proposition~\ref{pre-properties}
capture intuitive properties of belief and knowledge that lead to doxastic and
epistemic logics being referred to as the logics of belief and knowledge. The
property (\ref{pre-property-d}) is commonly known as the {\em Consistency
Axiom}, and ensures that an agent cannot have inconsistent beliefs.  The
related, but stronger property, (\ref{pre-property-t}) is commonly known as
the {\em Truth Axiom}, and ensures that an agent can only know statements that
are actually true. The properties (\ref{pre-property-4}), and
(\ref{pre-property-5}) are commonly known as the {\em Positive Introspection
Axiom} and the {\em Negative Introspection Axiom} respectively, and ensures that
if an agent knows (or believes) a statement, then they know that they know it
(or believe that they believe it), and likewise if they do not know or believe a
statement.

We note that the proofs of properties (\ref{pre-property-d}),
(\ref{pre-property-4}) and (\ref{pre-property-5}) rely only on the serial,
transitive and Euclidean properties of \classKD{} models, respectively. We also
note that the proof of property (\ref{pre-property-t}) relies only on the
reflexive property of \classS{} models. In fact, the class of Kripke models that
satisfy each of these properties are precisely the class of Kripke models that
satisfy the corresponding relational properties we have described; for example,
the class of Kripke models that satisfy property (\ref{pre-property-d}) is
precisely the class of models that have the serial property, and the class of
Kripke models that satisfy property (\ref{pre-property-4}) is precisely the
class of models that have the transitive property. This demonstrates a
connection between the structural constraints imposed upon doxastic and
epistemic models, and the properties we have described above, and we will refer
back to this connection shortly.

We will now provide a Hilbert-style axiomatisation for \logicK{}, \logicKD{} and
\logicS{}. A Hilbert-style axiomatisation gives a method for deriving valid
formulae in a logic. The type of axiomatisation that we give is called a
substitution schema, which comprises of a set of axioms and a set of rules. The
axioms are statements that contain variables, and substituting the variables for
well-formed formulae gives a valid statement in the logic. The rules provide a
method for deriving a validity from some other validities. The main results of
this paper are axiomatisations of this style for the variants of refinement
quantified modal logics.
 
\begin{definition}[Axiomatisation \axiomK{}]\label{pre-axiom-k}
The axiomatisation \axiomK{} is a substitution schema consisting of the
following axioms:
$$
\begin{array}{rl}
{\bf P} & \text{All propositional tautologies}\\
{\bf K} & \knows (\phi \implies \psi) \implies \knows \phi \implies \knows
\psi\\
\end{array}
$$

Along with the rules:
$$
\begin{array}{rl}
{\bf MP} & \text{From $\proves \phi \implies \psi$ and $\proves \phi$, infer
$\proves \psi$}\\
{\bf NecK} & \text{From $\proves \phi$ infer $\proves \knows_a \phi$}\\
\end{array}
$$
\end{definition}

We say that a formula $\phi$ is {\em provable} or {\em derivable} under an
axiomatisation if and only if it can be derived using some finite sequence of
axioms and rules from that axiomatisation, and we write $\proves \phi$. When we
are discussing multiple axiomatisations at once, we may add a subscript to the
turnstile symbol, e.g. $\proves_\axiomK \phi$, to make it more explicit which
logic we are referring to.

An axiomatisation of a logic must have two important properties: {\em soundness}
and {\em completeness}. An axiomatisation is sound with respect to a logic if
and only if every formula that can be derived from the axiomatisation is also
valid in that logic. An axiomatisation is complete if and only if every formula
that is valid in the logic is also derivable.

The axiomatisations for \logicKD{} and \logicS{} are extensions of the
axiomatisation \axiomK{}, which we will now provide.

\begin{definition}[Axiomatisation \axiomKD{}]
The axiomatisation \axiomKD{} is a substitution schema consisting of the axioms
and rules of \axiomK{}, along with the additional axioms:
$$
\begin{array}{rl}
{\bf D} & \knows \phi \implies \suspects \phi\\
{\bf 4} & \knows \phi \implies \knows \knows \phi\\
{\bf 5} & \suspects \phi \implies \knows \suspects \phi\\
\end{array}
$$
\end{definition}

We note that the additional axioms for \axiomKD{} correspond to the properties
of \classKD{} models described in Proposition~\ref{pre-properties}. The axioms
{\bf D}, {\bf 4} and {\bf 5} serve to restrict the logic to considering only the
Kripke models that are serial, transitive and Euclidean.

% TODO - Find citation

\begin{definition}[Axiomatisation \axiomS{}]
The axiomatisation \axiomS{} is a substitution schema consisting of the axioms
and rules of \axiomK{}, along with the additional axioms:
$$
\begin{array}{rl}
{\bf T} & \knows \phi \implies \suspects \phi\\
{\bf 5} & \suspects \phi \implies \knows \suspects \phi\\
\end{array}
$$
\end{definition}

% TODO - Find citation

Once again, we note that the additional axioms for \axiomS{} correspond to the
properties of \classS{} models described in Proposition~\ref{pre-properties}.
The axioms {\bf T} and {\bf 5} serve to restrict the logic to considering only
the Kripke models that are reflexive and Euclidean.  We note that the reflexive
and Euclidean properties together imply transitivity and symmetry.

\section{Bisimulation and refinements}

Having covered modal, epistemic and doxastic logics, we will now move on to
topics more specific to the focus of this paper, the refinement quantified modal
logics.  van Ditmarsch and French~\cite{french2010future} defined the future
event logic, an extension of modal logic that introduces an operator for
quantifying over the {\em refinements} of a Kripke model. The significance of
refinements is that the finite refinements of a Kripke model are exactly the
models that result from the execution of an action model. Here we define the
notion of a bisimulation, and define simulations and refinements in terms of the
properties of bisimulations.  We then remark on some properties of refinements
that make them suitable for representing informative updates.

\begin{definition}[Bisimulation]
Let $M = (S, R, V)$ and $M' = (S', R', V')$ be Kripke models. A non-empty
relation $\mathcal{R} \subseteq S \times S'$ is a \textit{bisimulation} if and
only if for all $s \in S$ and $s' \in S'$, with $(s, s') \in \mathcal{R}$, for
all $a \in A$:

\begin{description}
\item[atoms] $s \in V(p)$ if and only if $s' \in V'(p)$ for all
$p \in P$

\item[forth-$a$] for all $t \in S$, if $R_a(s, t)$, then there is a
$t' \in S'$ such that $R'_a(s', t')$ and $(t,
t') \in \mathcal{R}$

\item[back-$a$] for all $t' \in S'$, if $R'_a(s',
t')$, then there is a $t \in S$ such that $R_a(s, t)$ and $(t, t')
\in \mathcal{R}$.
\end{description}

We call $M_s$ and $M'_{s'}$ bisimilar, and write $M_s \bisim M'_{s'}$ to denote
that there is a bisimulation between $M_s$ and $M'_{s'}$.
\end{definition}

In the introduction of this chapter we remarked that modal logics are used to
reason about the {\em intrinsic} properties of Kripke models. The concept of
bisimilar Kripke models tells us how these intrinsic properties differ from the
extrinsic properties of Kripke models. In particular, for finite Kripke models,
bisimilar Kripke models satisfy precisely the same set of modal formulae as one
another. This means that bisimilar Kripke models are indistinguishable by modal
formulae. This property is known as bisimulation invariance.

\begin{lemma}
The logics \logicK{}, \logicKD{} and \logicS{} are bisimulation invariant.
\end{lemma}

% TODO - Find citation

If we relax the properties of bisimulation slightly, we get a related notion
known as a {\em simulation}, or its reverse relation, a {\em refinement}.

\begin{definition}[Simulation and refinement]
Let $M$ and $M'$ be Kripke models. A non-empty relation $\mathcal{R}
\subseteq S \times S'$ is a \textit{simulation} if and only if it satisfied {\bf
atoms} and {\bf forth-$a$} for every $a \in A$.

We call $M'_{s'}$ a simulation of $M_s$ and we call $M_s$ a refinement of
$M'_{s'}$. We write $M'_{s'} \simulation M_s$ to denote this, or alternatively,
$M_s \refinement M'_{s'}$.

A relation that satisfies {\bf atoms} and {\bf forth-$b$} for every $b \in A$,
and satisfies {\bf back-$b$} for every $b \in A - \{a\}$, for some $a \in A$, is
an $a$\textit{-simulation}. 

We call $M'_{s'}$ an $a$-simulation of $M_s$, and we call $M_s$ an
$a$-refinement of $M'_{s'}$. We write $M'_{s'} \simulation_a M_s$ to denote
this, or alternatively, $M_s \refinement_a M'_{s'}$.
\end{definition}

Whilst we have introduced simulations and refinements as relations between
models, we will often also refer to Kripke models as refinements or simulations
of other models. If $M_s \refinement_a M'_{s'}$ then we call $M_s$ an
$a$-refinement of $M'_{s'}$, and we call $M'_{s'}$ an $a$-simulation of $M_s$.

\begin{lemma}
The relation $\refinement_a$ is reflexive and transitive, and satisfies teh
Church-Rosser property over the class of \classK models.
\end{lemma}

As we have mentioned before, refinement quantified modal logics quantify over
informative updates, by quantifying over the refinements of a Kripke model. We
will briefly introduce two properties to illustrate how refinements correspond
to the notion of an informative update.

\begin{definition}[Positive formulae]
An $a$-positive formula is defined by the following abstract syntax:
$$
\alpha ::=  p \bnfalt
            \neg p \bnfalt
            \alpha \land \alpha \bnfalt
            \alpha \lor \alpha \bnfalt
            \knows_b \alpha \bnfalt
            \suspects_c \alpha
$$
where $p \in P$, $b \in A$ and $c \in A - \{a\}$.

A positive formula is defined by the following abstract syntax:
$$
\alpha ::=    p \bnfalt 
            \neg p \bnfalt
            \alpha \land \alpha \bnfalt
            \alpha \lor \alpha \bnfalt
            \knows_a \alpha
$$
where $p \in P$ and $a \in A$.
\end{definition}

\begin{proposition}
Let $M_s$ and $M'_{s'}$ be Kripke models such that $M'_{s'} \refinement_a M_s$,
and let $\phi$ be an $a$-positive formula. If $M_s \entails \phi$ then $M'_{s'}
\entails \phi$. This also holds if $\phi$ is a positive formula and/or $M'_{s'}$
is a refinement (rather than an $a$-refinement) of $M_s$.
\end{proposition}

Using an epistemic interpretation, the positive formulae can be interpreted as
those formulae that only mention {\em positive knowledge}. This is as opposed to
formulae which mention negative knowledge, such as $\neg \knows_a p$, or
suspicions. Intuitively one can say that an informative update should only cause
an agent to gain additional information, and cannot cause an agent to {\em
forget} any any information. Thus anything that an agent knows before an
informative update, the agent should continue to know after an informative
update.  This is not quite accurate, as a formula that involves negative
knowledge may potentially be invalidated by an informative update. For example,
suppose that we have a situation where $\knows_a \neg \knows_b p$, i.e. that $a$
knows that $b$ doesn't know that $p$. Then it is reasonable that an informative
update could tell $b$ that $p$, and so after the informative update $\knows_b
p$. This invalidates the statement that $\knows_a \neg \knows_b p$. Thus not all
knowledge is retained by an informative update, only positive knowledge should
be retained.

\begin{proposition}
On finite epistemic models, every finite refinement is equivalent to the
execution an action model.
\end{proposition}

This is shown by van Ditmarsch and French~\cite{french2009simulation}

The property that every finite refinements is equivalent to the execution of an
action model is the main justification for refinements as representations of
informative updates. Although we do not explicitly define action models in this
paper, it should be noted that action models are inherently finite structures,
whereas the refinements of even a finite model can potentially be infinite, and
therefore the above property does not hold for the infinite refinements of
epistemic models.
